if __name__ == '__main__':
    num_processes = 40
    pool = multiprocessing.Pool(processes=num_processes)
    results = []

    # ejecuta la función "my_function" en paralelo
    for i in range(num_processes):
        results.append(pool.apply_async(my_function))

    # obtiene los resultados de los procesos
    for result in results:
        result.wait()

    # cierra el pool de procesos
    pool.close()
    pool.join()
En este ejemplo, creamos un objeto Pool del módulo multiprocessing y le pasamos el número de procesos que deseamos ejecutar en paralelo. Luego, usamos un bucle for para llamar a la función my_function en cada proceso utilizando el método apply_async. Esto devuelve un objeto AsyncResult que podemos almacenar en una lista llamada results.

Después de iniciar los procesos, esperamos a que terminen llamando al método wait en cada objeto AsyncResult. Finalmente, cerramos el pool de procesos y esperamos a que todos los procesos terminen usando el método join.

Este es solo un ejemplo básico, pero el módulo multiprocessing de Python ofrece muchas otras funciones y opciones para controlar el comportamiento de los procesos en paralelo.






